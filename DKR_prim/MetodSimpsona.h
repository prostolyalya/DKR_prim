#include "math.h" //Бібліотека математичних функцій
#include <fstream> //Бібліотека для роботи з файлами
#include <iostream> //Бібліотека вводу/виводу

using std::ofstream; using std::cout; using std::cin; using std::endl;

class MetodSimpsona
{
public: //Інтерфейс класу
	MetodSimpsona() = default; //Конструктор класу за замовчуванням
	MetodSimpsona(const float &a, const float &b, const float &eps) : A(a), B(b), Eps(eps) {}; //Конструктор класу
	MetodSimpsona(const float &a, const float &b) : A(a), B(b) {}; //Конструктор класу
	void Metod(); // Оголошення функції-члену класу без параметрів
private: //Реалізація класу
	float A = -1.7, B = 0.3, Eps = 0.01; //Ініціалізація даних-членів класу
	double Function(const double&); // Оголошення функції-члену класу з параметром - констант-ним посиланням
};

void MetodSimpsona::Metod() //Визначення функції-члену класу без параметрів
{
	float a(A), b(B), eps(Eps); size_t n = 5, i; char txt; //Оголошення змінних
	double h, x, I, Int1, Int2 = 0, sum1, sum2, sum3;
	ofstream outfile("DKR.txt", ofstream::app); //Зв'язок із файлом, для дозапису результатів розрахунків
	outfile << endl << "Розрхунок інтеграла I(x є [" << a << "," << b << "]) = ln(x^2 + 0.9)dx/(x-1) методом сімпсона:" << endl;
	cout << "Вивести проміжні розрахунки? [y]/[n]  "; cin >> txt; //Запит для виводу проміжних розрхунків
	h = (b - a) / (n - 1); //Розрахунок початкового кроку інтерування
	do //Цикл розрахунку та виводу інтеграла методом сімпсона
	{
		if (txt == 'y') //Перевірка умови на вивід проміжних розрахунків
		{//Вивід проміжних розрахунків
			cout << endl << "Проміжні розрахуники із кроком h = " << h << ":" << endl;
			outfile << endl << "Проміжні розрахуники із кроком h = " << h << ":" << endl;
		}
		sum1 = 0; sum2 = 0; sum3 = 0; Int1 = Int2; //Переприсвоєння контрольних сум та ро-зрахованого інтеграла
		for (i = 0; i != n; i++) //Цикл перебору 'х' на проміжку [a,b] з кроком h
		{
			x = a + i * h; //Розрхунок поточного значення 
			I = Function(x); //Виклик функції для розрахунку поточно значння інтеграла
			if (i == 0 || i == n - 1) { sum1 += I; } //Перевірка умови сумування значень інтеграла
			else
			{
				if (fmod(i, 2) == 0) { sum3 += I; } //Сумування не парних елементів
				else { sum2 += I; } //Сумування парних елементів
			}
			if (txt == 'y') //Перевірка умови на вивід проміжних розрахунків
			{//Вивід проміжних розрахунків
				cout << "Ітерація №" << i + 1 << "; при х = " << x << "; І = " << I << endl;
				outfile << "Ітерація №" << i + 1 << "; при х = " << x << "; І = " << I << endl;
			}
		}
		Int2 = h / 3 * (sum1 + 4 * sum2 + 2 * sum3); //Розрахунок інтеграла методом сімпсо-на
		if (txt == 'y') //Перевірка умови на вивід проміжних розрахунків
		{//Вивід проміжних розрахунків
			cout << "Розрахований інтеграл І = " << h << " / 3 * (" << sum1 << " + 4 * " << sum2 << " + 2 * " << sum3 << ") = " << Int2 << endl;
			outfile << "Розрахований інтеграл І = " << h << " / 3 * (" << sum1 << " + 4 * " << sum2 << " + 2 * " << sum3 << ") = " << Int2 << endl;
		}
		h /= 2; n = (b - a) / h + 1; //Розрахунок наступного кроку та кількості точок інте-грування
	} while (fabs(Int1 - Int2) > eps); //Перевірка точності розрахованого інтеграла
	cout << endl << "Інтеграл І = " << Int2 << ", розраховано із точністю eps = " << eps << ", при кроці h = " << h << endl;
	outfile << endl << "Інтеграл І = " << Int2 << ", розраховано із точністю eps = " << eps << ", при кроці h = " << h << endl;
}

double MetodSimpsona::Function(const double &x) //Визначення функції-члену класу з параметром – константним посиланням
{
	double I; //Оголошення змінної
	if (x - 1 == 0) { I = 0; } //Виключення ділення на нуль
	else { I = log(pow(x, 2) + 0.9) / (x - 1); } //Розрахунок поточно значння інтеграла
	return I; //Повернення значення інтеграла
}
